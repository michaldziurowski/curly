#!/usr/bin/env bash

# Curly - HTTP API chaining tool with template variables
# https://github.com/yourusername/curly

set -euo pipefail

# Script configuration
readonly SCRIPT_NAME="curly"
readonly VERSION="1.0.0"
STATE_FILE="./.curly-state"
readonly TEMP_DIR="${TMPDIR:-/tmp}"
readonly RESPONSE_FILE="${TEMP_DIR}/${SCRIPT_NAME}-response-$$.json"
readonly HEADERS_FILE="${TEMP_DIR}/${SCRIPT_NAME}-headers-$$.txt"

# Colors for output (check if terminal supports colors)
if [[ -t 1 ]] && command -v tput &>/dev/null && [[ $(tput colors) -ge 8 ]]; then
    readonly RED='\033[0;31m'
    readonly GREEN='\033[0;32m'
    readonly YELLOW='\033[1;33m'
    readonly BLUE='\033[0;34m'
    readonly CYAN='\033[0;36m'
    readonly NC='\033[0m' # No Color
else
    readonly RED=''
    readonly GREEN=''
    readonly YELLOW=''
    readonly BLUE=''
    readonly CYAN=''
    readonly NC=''
fi

# Cleanup temporary files on exit
trap 'rm -f "$RESPONSE_FILE" "$HEADERS_FILE"' EXIT INT TERM

# ============================================================================
# Helper Functions
# ============================================================================

# Display usage information
usage() {
    cat << EOF
${BLUE}Curly v${VERSION}${NC} - HTTP API chaining tool with template variables

${YELLOW}Usage:${NC}
  $SCRIPT_NAME METHOD URL [OPTIONS]
  $SCRIPT_NAME --list|--clear|--help|--version

${YELLOW}Arguments:${NC}
  METHOD              HTTP method (GET, POST, PUT, DELETE, PATCH, etc.)
  URL                 Request URL (supports {{variable}} templates)

${YELLOW}Options:${NC}
  -d, --data <json>           Request body (supports templates)
  -H, --header <header>       HTTP header (repeatable, supports templates)
  -s, --save <var=jq_expr>    Save response value (repeatable)
                              Example: -s 'token=.auth.token'
  -o, --output <file>         Save raw response to file
  -v, --verbose               Show debug information
  -q, --quiet                 Suppress response output
  --timeout <seconds>         Request timeout (default: 30)
  --no-format                 Don't format JSON output

${YELLOW}State Management:${NC}
  --list                      List all saved variables
  --clear                     Clear all saved variables
  --set <var=value>           Manually set a variable
  --unset <var>               Remove a specific variable
  --state-file <path>         Use alternate state file (default: ./.curly-state)

${YELLOW}Other:${NC}
  --help                      Show this help message
  --version                   Show version information

${YELLOW}Examples:${NC}
  # Simple GET request
  $SCRIPT_NAME GET https://api.example.com/users

  # POST with body and save response values
  $SCRIPT_NAME POST https://api.example.com/login \\
    -d '{"username":"user","password":"pass"}' \\
    -s 'token=.auth.token' \\
    -s 'user_id=.user.id'

  # Use saved variables in URL and headers
  $SCRIPT_NAME GET 'https://api.example.com/users/{{user_id}}' \\
    -H 'Authorization: Bearer {{token}}'

  # Chain requests with saved data
  $SCRIPT_NAME POST 'https://api.example.com/projects' \\
    -H 'Authorization: Bearer {{token}}' \\
    -d '{"name":"Project","owner":{{user_id}}}' \\
    -s 'project_id=.id'

${YELLOW}Template Syntax:${NC}
  Use {{variable_name}} in URLs, headers, or request bodies to reference
  saved values. Variables are stored in ./.curly-state in the current directory.

${YELLOW}Dependencies:${NC}
  - curl (for HTTP requests)
  - jq (for JSON parsing)

EOF
}

# Print error message and exit
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

# Print warning message
warn() {
    echo -e "${YELLOW}Warning: $1${NC}" >&2
}

# Print success message
success() {
    echo -e "${GREEN}✓ $1${NC}" >&2
}

# Print info message
info() {
    echo -e "${CYAN}ℹ $1${NC}" >&2
}

# Print debug message (only in verbose mode)
debug() {
    if [[ "${VERBOSE:-0}" == "1" ]]; then
        echo -e "${BLUE}Debug: $1${NC}" >&2
    fi
}

# Check for required dependencies
check_dependencies() {
    local missing_deps=()

    if ! command -v curl &>/dev/null; then
        missing_deps+=("curl")
    fi

    if ! command -v jq &>/dev/null; then
        missing_deps+=("jq")
    fi

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        error "Missing required dependencies: ${missing_deps[*]}. Please install them first."
    fi
}

# ============================================================================
# State Management Functions
# ============================================================================

# Initialize state file if it doesn't exist
init_state_file() {
    if [[ ! -f "$STATE_FILE" ]]; then
        touch "$STATE_FILE"
        debug "Created state file: $STATE_FILE"
    fi
}

# Load all variables from state file into associative array
declare -A STATE_VARS
load_state() {
    STATE_VARS=()

    if [[ -f "$STATE_FILE" ]]; then
        while IFS='=' read -r key value; do
            if [[ -n "$key" && "$key" != \#* ]]; then
                STATE_VARS["$key"]="$value"
                debug "Loaded: $key = ${value:0:50}..."
            fi
        done < "$STATE_FILE"
    fi
}

# Save a variable to state file
save_variable() {
    local key="$1"
    local value="$2"

    init_state_file

    # Remove existing entry if present
    if [[ -f "$STATE_FILE" ]]; then
        grep -v "^${key}=" "$STATE_FILE" > "${STATE_FILE}.tmp" 2>/dev/null || true
        mv "${STATE_FILE}.tmp" "$STATE_FILE"
    fi

    # Escape the value to handle special characters
    printf '%s=%s\n' "$key" "$value" >> "$STATE_FILE"

    debug "Saved variable: $key = ${value:0:50}..."
}

# Remove a variable from state file
unset_variable() {
    local key="$1"

    if [[ -f "$STATE_FILE" ]]; then
        grep -v "^${key}=" "$STATE_FILE" > "${STATE_FILE}.tmp" 2>/dev/null || true
        mv "${STATE_FILE}.tmp" "$STATE_FILE"
        success "Removed variable: $key"
    else
        warn "No state file found"
    fi
}

# List all saved variables
list_variables() {
    if [[ ! -f "$STATE_FILE" || ! -s "$STATE_FILE" ]]; then
        info "No variables saved in $STATE_FILE"
        return
    fi

    echo -e "${CYAN}Saved variables in $STATE_FILE:${NC}"
    while IFS='=' read -r key value; do
        if [[ -n "$key" && "$key" != \#* ]]; then
            # Truncate long values for display
            local display_value="$value"
            if [[ ${#value} -gt 60 ]]; then
                display_value="${value:0:57}..."
            fi
            echo "  ${YELLOW}$key${NC} = $display_value"
        fi
    done < "$STATE_FILE"
}

# Clear all variables
clear_variables() {
    if [[ -f "$STATE_FILE" ]]; then
        > "$STATE_FILE"
        success "Cleared all variables from $STATE_FILE"
    else
        info "No state file to clear"
    fi
}

# ============================================================================
# Template Processing Functions
# ============================================================================

# Replace {{variable}} templates in string
replace_templates() {
    local input="$1"
    local output="$input"

    # Find all {{variable}} patterns
    local patterns
    patterns=$(echo "$input" | grep -oE '\{\{[a-zA-Z0-9_-]+\}\}' 2>/dev/null | sort -u || true)

    if [[ -z "$patterns" ]]; then
        echo "$output"
        return 0
    fi

    # Load current state
    load_state

    # Replace each pattern
    while IFS= read -r pattern; do
        [[ -z "$pattern" ]] && continue

        # Extract variable name (remove {{ and }})
        local var_name="${pattern:2:-2}"

        # Get value from state
        if [[ -v STATE_VARS["$var_name"] ]]; then
            local var_value="${STATE_VARS[$var_name]}"
            debug "Replacing $pattern with $var_value"

            # Use string replacement instead of sed for simple substitution
            # This avoids complex escaping issues
            output="${output//$pattern/$var_value}"
        else
            error "Variable '$var_name' not found. Use --list to see available variables."
        fi
    done <<< "$patterns"

    echo "$output"
}

# ============================================================================
# HTTP Request Functions
# ============================================================================

# Execute HTTP request
execute_request() {
    local method="$1"
    local url="$2"
    shift 2

    local curl_args=(
        -X "$method"
        -s
        -w '\n%{http_code}'
        -o "$RESPONSE_FILE"
        -D "$HEADERS_FILE"
        --max-time "${TIMEOUT:-30}"
    )

    # Add custom headers and data from remaining arguments
    curl_args+=("$@")

    # Add URL
    curl_args+=("$url")

    debug "Executing: curl ${curl_args[*]}"

    # Execute request and capture HTTP status code
    local http_code
    if ! http_code=$(curl "${curl_args[@]}" 2>&1); then
        error "Request failed: $http_code"
    fi

    # Extract numeric status code (last line of output)
    http_code=$(echo "$http_code" | tail -n1)

    # Save HTTP status code
    save_variable "last_http_code" "$http_code"

    debug "HTTP Status: $http_code"

    # Check for client/server errors
    if [[ "$http_code" -ge 400 ]]; then
        warn "HTTP $http_code response"
        if [[ -s "$RESPONSE_FILE" ]]; then
            echo -e "${RED}Error response:${NC}" >&2
            jq '.' "$RESPONSE_FILE" 2>/dev/null || cat "$RESPONSE_FILE" >&2
        fi
        return 1
    fi

    return 0
}

# Extract and save values from JSON response
extract_values() {
    local save_expr="$1"
    local response_file="$2"

    # Split on first = to separate variable name and jq expression
    local var_name="${save_expr%%=*}"
    local jq_expr="${save_expr#*=}"

    if [[ "$var_name" == "$save_expr" ]]; then
        error "Invalid save expression. Use format: var_name=.json.path"
    fi

    debug "Extracting: $var_name = jq '$jq_expr'"

    # Extract value using jq (using -rc for compact output)
    local value
    if ! value=$(jq -rc "$jq_expr" < "$response_file" 2>/dev/null); then
        warn "Failed to extract value with expression: $jq_expr"
        return 1
    fi

    if [[ "$value" == "null" || -z "$value" ]]; then
        warn "Expression '$jq_expr' returned null or empty value"
        return 1
    fi

    # Save the extracted value
    save_variable "$var_name" "$value"
    success "Saved: $var_name = ${value:0:60}..."

    return 0
}

# ============================================================================
# Main Function
# ============================================================================

main() {
    # Check dependencies
    check_dependencies

    # Initialize variables
    local method=""
    local url=""
    local data=""
    local headers=()
    local saves=()
    local output_file=""
    local verbose=0
    local quiet=0
    local no_format=0
    local timeout=30
    local custom_state_file=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                usage
                exit 0
                ;;
            --version)
                echo "Curly version $VERSION"
                exit 0
                ;;
            --list)
                list_variables
                exit 0
                ;;
            --clear)
                clear_variables
                exit 0
                ;;
            --set)
                shift
                [[ $# -eq 0 ]] && error "--set requires an argument"
                local set_expr="$1"
                local set_key="${set_expr%%=*}"
                local set_value="${set_expr#*=}"
                [[ "$set_key" == "$set_expr" ]] && error "Invalid format. Use: --set var=value"
                save_variable "$set_key" "$set_value"
                success "Set: $set_key = $set_value"
                exit 0
                ;;
            --unset)
                shift
                [[ $# -eq 0 ]] && error "--unset requires a variable name"
                unset_variable "$1"
                exit 0
                ;;
            --state-file)
                shift
                [[ $# -eq 0 ]] && error "--state-file requires a path"
                custom_state_file="$1"
                STATE_FILE="$custom_state_file"
                ;;
            -d|--data)
                shift
                [[ $# -eq 0 ]] && error "$1 requires an argument"
                data="$1"
                ;;
            -H|--header)
                shift
                [[ $# -eq 0 ]] && error "$1 requires an argument"
                headers+=("$1")
                ;;
            -s|--save)
                shift
                [[ $# -eq 0 ]] && error "$1 requires an argument"
                saves+=("$1")
                ;;
            -o|--output)
                shift
                [[ $# -eq 0 ]] && error "$1 requires an argument"
                output_file="$1"
                ;;
            -v|--verbose)
                verbose=1
                VERBOSE=1
                ;;
            -q|--quiet)
                quiet=1
                ;;
            --no-format)
                no_format=1
                ;;
            --timeout)
                shift
                [[ $# -eq 0 ]] && error "--timeout requires a value"
                timeout="$1"
                TIMEOUT="$timeout"
                ;;
            -*)
                error "Unknown option: $1"
                ;;
            *)
                if [[ -z "$method" ]]; then
                    method="${1^^}"  # Convert to uppercase
                elif [[ -z "$url" ]]; then
                    url="$1"
                else
                    error "Unexpected argument: $1"
                fi
                ;;
        esac
        shift
    done

    # Validate required arguments
    [[ -z "$method" ]] && error "HTTP method is required"
    [[ -z "$url" ]] && error "URL is required"

    # Validate HTTP method
    case "$method" in
        GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS|TRACE|CONNECT)
            ;;
        *)
            warn "Unusual HTTP method: $method"
            ;;
    esac

    # Load state and replace templates
    debug "Processing templates..."
    url=$(replace_templates "$url")

    # Process data if provided
    local curl_data_args=()
    if [[ -n "$data" ]]; then
        data=$(replace_templates "$data")
        curl_data_args+=(-H "Content-Type: application/json")
        curl_data_args+=(-d "$data")
        debug "Request body: $data"
    fi

    # Process headers
    local curl_header_args=()
    for header in "${headers[@]}"; do
        header=$(replace_templates "$header")
        curl_header_args+=(-H "$header")
        debug "Header: $header"
    done

    # Execute the request
    info "Executing: $method $url"
    if execute_request "$method" "$url" "${curl_header_args[@]}" "${curl_data_args[@]}"; then

        # Process response
        if [[ -s "$RESPONSE_FILE" ]]; then
            # Extract and save values if requested
            for save_expr in "${saves[@]}"; do
                extract_values "$save_expr" "$RESPONSE_FILE"
            done

            # Save response to file if requested
            if [[ -n "$output_file" ]]; then
                cp "$RESPONSE_FILE" "$output_file"
                success "Response saved to: $output_file"
            fi

            # Display response unless quiet
            if [[ "$quiet" -eq 0 ]]; then
                if [[ "$no_format" -eq 1 ]]; then
                    cat "$RESPONSE_FILE"
                else
                    # Try to format as JSON, fallback to raw if not valid JSON
                    if ! jq '.' "$RESPONSE_FILE" 2>/dev/null; then
                        cat "$RESPONSE_FILE"
                    fi
                fi
            fi
        else
            debug "Empty response body"
        fi

        # Show success status
        local http_code="${STATE_VARS[last_http_code]:-unknown}"
        success "Request completed (HTTP $http_code)"
    else
        exit 1
    fi
}

# ============================================================================
# Script Entry Point
# ============================================================================

# Run main function with all arguments
main "$@"